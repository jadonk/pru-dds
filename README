This project is a Direct Digital Synthesizer for the Beaglebone Black
PRU.  You can load its wavetable with various waveshapes, and you can
have it run at all sorts of different frequencies with surprising
resolution (at 3KHz, it has about 1/100 Hz resolution).  Hooked to
an op-amp it could be used as a pretty good low-frequency signal
generator for testing things, or perhaps be the LO for something?

Be aware, PRU fast GPIO is incompatible with the HDMI, so firstly
you can't use them together, and secondly, you'll have to disable
the HDMI by doing the following:

# mount /dev/mmcblk0p1 /mnt/card
You should find the file "/mnt/card/uEnv.txt", which should have a
single line of text in it, to which you should append the following:
# capemgr.disable_partno=BB-BONELT-HDMI,BB-BONELT-HDMIN
So for example if the file contains 
optargs=quiet
You should change it to contain
optargs=quiet capemgr.disable_partno=BB-BONELT-HDMI,BB-BONELT-HDMIN
Having done this, save the file and reboot.

Look for output from P9 31,29,30,28,42,27,41,25 (LSB to MSB) ready to
feed into an R-2R or other DAC.  IF you modify config.pl to use PRU1
instead of PRU0, look for output on P8 45,46,43,44,41,42,39,40. 
Running on PRU1 has only been tested so far as compiling the dtbo and
successfully installing it, so it may not work at all.  Be aware that
since in my experience uninstalling a dtbo requires a reboot anyway,
I make all variants of my dtbo have the same name (which is probably 
very very bad practice.  I'll deal with that if someone finds a
legitimate reason to complain about it.

Below are some notes on what I might do with this thing.  These notes
were written before I added config.pl, which I did in the furtherance
of these vaguely stated goals.

Presently, we have a wavetable size of 8 kilosamples and a sample rate
of 28.571429 megasamples/second.  This means that until you get down to
3571.4 Hz, each sample output will be a fresh one from the table.  Below
this frequency we may sit at one position in the table for longer that
one sample duration. If we drop the wavetable size to 4 kilosamples,
then this limiting frequency will be 7142.86Hz. Now, what this will do
is effectively lower the sample rate, such that, say, if we get down to
1785.7 Hz with the current wavetable size and sample rate, the effective
sample rate will be 14.285715 Msam/sec. You'll notice that the frequency
of interest, 1785, is well below nyquist still. We will always at all
frequencies be well below nyquist, but below samplerate/tablesize, nyquist
will decrease.

This seems to me to be no big thing, so I'm presently comtemplating dropping
half of the wavetable so it's only 4ksam in size, so I can use the rest of
PRU memory for configuration, for example, passing in skiplen without having
to restart the code. Doing this will likely lower the samplerate more, but
will allow for instantaneous frequency changes with no glitches under (main
CPU) software control.

The way I can think of of passing skiplen to the PRU the fastest is to
interlace skiplen with the wavetable.  That way skiplen and the current sample
can be read in in one read operation, assuming we can use R30.b1 for data
storage. We don't necessarily read every sample every pass through the table,
so we'd have to write skiplen to every second position in the table, and we'd
need a way to avoid glitching while we're filling up the table with four
thousand copies of skiplen ...

Oh, a seperate read is needed anyway because skiplen is 32 bits. Which is four
CPU cycles, right? Hmmm...

It'll also allow FMing of the signal. I'm totally doing this.

I may write a program for the second PRU that FMs the first PRU.

Also on the horizon, using the PRU's MAC to allow for amplitude modification,
which will be another integer we pass through PRU DataRam as we do with
skiplen.  Not sure if we can do multiplication of signed integers, but that
would be the easiest way to implement a cosine-shaped BPSK transmitter.  I
can then, of course, write a BPSK transmitter that runs in the second PRU.
Or an ASK transmitter, or AM, or QAM, or whatever.

All of this will lower the sample rate, but hopefully lead to some interesting
projects.  I may fork the high-speed DDS to make the super-extensible one.

I will probably also make things a lot less path-dependant at some point (it
was a quick weekend hack!)
